/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "tuplas.h"
#include <string.h>
#include "claves.h"

bool_t
destroy_1_1_svc(Respuesta *result, struct svc_req *rqstp)
{
	bool_t retval;
	retval = TRUE;

	result->result = destroy();

	return retval;
}

bool_t
set_value_1_1_svc(Peticion argp, Respuesta *result,  struct svc_req *rqstp)
{
	bool_t retval;
	retval = TRUE;

	struct Coord aux;
	aux.x = argp.value3.x;
	aux.y = argp.value3.y;

	result->result = set_value(
		argp.key,
		argp.value1,
		argp.N_value2,
		argp.V_value2.V_value2_val,
		aux
	);

	return retval;
}

bool_t
get_value_1_1_svc(Peticion argp, RespuestaGetValue *result,  struct svc_req *rqstp)
{
	bool_t retval;
	retval = TRUE;

	result->value1 = strdup("");

        double *temp = (double *)malloc(32 * sizeof(double));

	struct Coord aux;
	result->result = get_value(
		argp.key,
		result->value1,
		&result->N_value2,
		temp,
		&aux
	);

        result->V_value2.V_value2_len = result->N_value2;
        for (int i = 0; i < result->N_value2; i++) {
            result->V_value2.V_value2_val[i] = temp[i];
        }

	result->value3.x = aux.x;
	result->value3.y = aux.y;

        free(temp);

	return retval;
}

bool_t
modify_value_1_1_svc(Peticion argp, Respuesta *result,  struct svc_req *rqstp)
{
	bool_t retval;
	retval = TRUE;

	struct Coord aux;
	aux.x = argp.value3.x;
	aux.y = argp.value3.y;

	result->result = modify_value(
		argp.key,
		argp.value1,
		argp.N_value2,
		argp.V_value2.V_value2_val,
		aux
	);

	return retval;
}

bool_t
delete_key_1_1_svc(Peticion argp, Respuesta *result,  struct svc_req *rqstp)
{
	bool_t retval;
	retval = TRUE;

	result->result = delete_key(argp.key);

	return retval;
}

bool_t
exist_1_1_svc(Peticion argp, Respuesta *result,  struct svc_req *rqstp)
{
	bool_t retval;
	retval = TRUE;

	result->result = exist(argp.key);

	return retval;
}

int
tuplas_prog_1_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free (xdr_result, result);

	/*
	 * Insert additional freeing code here, if needed
	 */

	return 1;
}
