/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <string.h>
#include <pthread.h>
#include <stdlib.h>
#include <stdio.h>
#include "claves.h"
#include "tuplas.h"

static CLIENT *clnt;  // Cliente RPC, privado en este archivo
pthread_mutex_t rpc_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t rpc_cond = PTHREAD_COND_INITIALIZER;
int rpc_initialized = 0;

// Función para inicializar el cliente RPC
int rpc_init(void) {
    printf("Iniciando\n");

    pthread_mutex_lock(&rpc_mutex);
    while (rpc_initialized) {
        pthread_cond_wait(&rpc_cond, &rpc_mutex);
    }
    rpc_initialized = 1;

    char *server_ip = getenv("IP_TUPLAS");
    if (server_ip == NULL) {
        fprintf(stderr, "Error: IP_TUPLAS no está definida en el entorno\n");
        return -1;
    }

    clnt = clnt_create(server_ip, TUPLAS_PROG, TUPLAS_VERS, "udp");
    if (clnt == NULL) {
        clnt_pcreateerror(server_ip);
        return -1;
    }
    return 0;
}

// Función para limpiar el cliente RPC
void rpc_close() {
    printf("Cerrando\n");
    if (clnt != NULL) {
        clnt_destroy(clnt);
        clnt = NULL;
    }

    rpc_initialized = 0;

    pthread_cond_signal(&rpc_cond);

    pthread_mutex_unlock(&rpc_mutex);
}

int set_value(int key, char *value1, int N_value2, double *V_value2, struct Coord value3) {
    rpc_init();

    Peticion req;
    memset(&req, 0, sizeof(Peticion));

    Respuesta result;
    enum clnt_stat retval;

    req.key = key;
    req.value1 = strdup(value1);
    req.N_value2 = N_value2;

    req.V_value2.V_value2_len = req.N_value2;
    for (int i = 0; i < req.N_value2; i++) {
        req.V_value2.V_value2_val[i] = V_value2[i];
    }

    struct CoordAux aux;
    aux.x = value3.x;
    aux.y = value3.y;
    req.value3 = aux;

    retval = set_value_1_1(req, &result, clnt);
    if (retval != RPC_SUCCESS) {
        clnt_perror(clnt, "set_value RPC call failed");
        free(req.value1);
        return -1;
    }

    free(req.value1);

    rpc_close();
    return result.result;
}

int get_value(int key, char *value1, int *N_value2, double *V_value2, struct Coord *value3) {
    rpc_init();
    Peticion req;
    memset(&req, 0, sizeof(Peticion));
    RespuestaGetValue result;
    memset(&result, 0, sizeof(RespuestaGetValue));
    enum clnt_stat retval;

    req.key = key;

    req.value1 = strdup("");

    req.N_value2 = 0;
    req.V_value2.V_value2_len = req.N_value2;

    struct CoordAux aux = {0};
    req.value3 = aux;

    retval = get_value_1_1(req, &result, clnt);
    if (retval != RPC_SUCCESS) {
        clnt_perror(clnt, "get_value RPC call failed");
        return -1;
    }

    if (result.result == 0) {
        strncpy(value1, result.value1, 256);
        *N_value2 = result.N_value2;
        for (int i = 0; i < *N_value2; i++) {
            V_value2[i] = result.V_value2.V_value2_val[i];
	}

	struct Coord aux;
        aux.x = result.value3.x;
        aux.y = result.value3.y;
        *value3 = aux;
    }

    free(req.value1);

    rpc_close();
    return result.result;
}

int modify_value(int key, char *value1, int N_value2, double *V_value2, struct Coord value3) {
    rpc_init();

    Peticion req;
    memset(&req, 0, sizeof(Peticion));

    Respuesta result;
    enum clnt_stat retval;

    req.key = key;
    req.value1 = strdup(value1);
    req.N_value2 = N_value2;

    req.V_value2.V_value2_len = req.N_value2;
    for (int i = 0; i < req.N_value2; i++) {
        req.V_value2.V_value2_val[i] = V_value2[i];
    }

    struct CoordAux aux;
    aux.x = value3.x;
    aux.y = value3.y;
    req.value3 = aux;

    retval = modify_value_1_1(req, &result, clnt);
    if (retval != RPC_SUCCESS) {
        clnt_perror(clnt, "set_value RPC call failed");
        free(req.value1);
        return -1;
    }

    free(req.value1);

    rpc_close();
    return result.result;
}

int exist(int key) {
    rpc_init();
    Peticion req;
    memset(&req, 0, sizeof(Peticion));
    Respuesta result;
    enum clnt_stat retval;

    req.key = key;

    req.value1 = strdup("");

    req.N_value2 = 0;
    req.V_value2.V_value2_len = req.N_value2;

    struct CoordAux aux = {0};
    req.value3 = aux;

    retval = exist_1_1(req, &result, clnt);
    if (retval != RPC_SUCCESS) {
        clnt_perror(clnt, "exist RPC call failed");
        return -1;
    }

    rpc_close();
    return result.result;
}

int destroy() {
    rpc_init();
    Respuesta result;
    enum clnt_stat retval;

    retval = destroy_1_1(&result, clnt);
    if (retval != RPC_SUCCESS) {
        clnt_perror(clnt, "destroy RPC call failed");
        return -1;
    }

    rpc_close();
    return result.result;
}

int delete_key(int key) {
    rpc_init();
    Peticion req;
    memset(&req, 0, sizeof(Peticion));
    Respuesta result;
    enum clnt_stat retval;

    req.key = key;

    req.value1 = strdup("");

    req.N_value2 = 0;
    req.V_value2.V_value2_len = req.N_value2;

    struct CoordAux aux = {0};
    req.value3 = aux;

    retval = delete_key_1_1(req, &result, clnt);
    if (retval != RPC_SUCCESS) {
        clnt_perror(clnt, "delete_key RPC call failed");
        return -1;
    }

    rpc_close();
    return result.result;
}
/*
void
tuplas_prog_1(char *host)
{
	CLIENT *clnt;
	enum clnt_stat retval_1;
	Respuesta result_1;
	
	enum clnt_stat retval_2;
	Respuesta result_2;
	Peticion set_value_1_1_arg1;
	
	enum clnt_stat retval_3;
	RespuestaGetValue result_3;
	Peticion get_value_1_1_arg1;
	
	enum clnt_stat retval_4;
	Respuesta result_4;
	Peticion modify_value_1_1_arg1;
	
	enum clnt_stat retval_5;
	Respuesta result_5;
	Peticion delete_key_1_1_arg1;
	
	enum clnt_stat retval_6;
	Respuesta result_6;
	Peticion exist_1_1_arg1;
	*/
	

	/*retval_1 = destroy_1_1(&result_1, clnt);
	if (retval_1 != RPC_SUCCESS) {
		clnt_perror (clnt, "call failed");
	}
	retval_2 = set_value_1_1(set_value_1_1_arg1, &result_2, clnt);
	if (retval_2 != RPC_SUCCESS) {
		clnt_perror (clnt, "call failed");
	}
	retval_3 = get_value_1_1(get_value_1_1_arg1, &result_3, clnt);
	if (retval_3 != RPC_SUCCESS) {
		clnt_perror (clnt, "call failed");
	}
	retval_4 = modify_value_1_1(modify_value_1_1_arg1, &result_4, clnt);
	if (retval_4 != RPC_SUCCESS) {
		clnt_perror (clnt, "call failed");
	}
	retval_5 = delete_key_1_1(delete_key_1_1_arg1, &result_5, clnt);
	if (retval_5 != RPC_SUCCESS) {
		clnt_perror (clnt, "call failed");
	}
	retval_6 = exist_1_1(exist_1_1_arg1, &result_6, clnt);
	if (retval_6 != RPC_SUCCESS) {
		clnt_perror (clnt, "call failed");
	}

	clnt_destroy (clnt);

}*/
